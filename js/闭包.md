### 闭包

#### js的隐式调用
```JS
#首先举一个简单的例子，
let a = 1;
a + '';
#这个时候a将会调用toString函数将数字类型转化为字符串类型
```
在js中，一切皆对象，在对象的原型链一般都会定义了toString（回一个反映这个对象的字符串）和valueOf（返回它相应的原始值）方法。
```JS
let a = new Number();
typeof a  # 'object'
# 也就是说a为object类型，想要对它进行操作，就得先调用toString或者valueOf获取它的原始值
# 当对a(对象在作为操作数时)进行运算操作(加减乘除，逻辑判断,valueOf的优先级该与toString)时,这时会调用它的valueOf方法.而其他情况，解释器总是认为我们想要的是字符串，所以会优先调用toString()

# Date类型是个特例, Date类型的对象之所以会在二元+运算时优先调用toString(),也是因为我们大多数情况下， 时间总是和字符串连接使用，而时间和一个数字相加的情况好少,所以Date类型中，toString()优先级才比较高。

对象到字符串的转换：
1.如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，js将这个值转换成字符串，并返还这个字符串结果。
2.如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么js将调用valueOf()方法。
3.否则，js无法从toString()或者valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。

对象到数字的转换：
1.如果对象具有valueOf()方法，后者返回一个原始值，则js将这个原始值转换成数字，并返回这个数字。
2.否则，如果对象具有toString()方法，后者返回一个原始值，则js将转换并返回。首先js转换成相应的字符串原始值，再继续将这个原始值转换成相应的数字类型，再返回数字）
3.否则，js抛出一个类型错误异常。

```



JavaScript固有对象的 valueOf 方法定义不同。

| 对象     | 返回值                                                       |
| -------- | ------------------------------------------------------------ |
| Array    | 数组没有valueOf方法，继承的是Object.prototype.valueOf的原始方法，返回数组本身 |
| Boolean  | Boolean 值。                                                 |
| Date     | 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。     |
| Function | 同Array                                                      |
| Number   | 数字值。                                                     |
| Object   | 对象本身。这是默认情况。                                     |
| String   | 字符串值。                                                   |



```JS
function addCarring(a) {
  let sum = a;
  const add = function (b) {
    sum += b;
    return add;
  }
  add.toString = function () {
    return sum;
  }
  return add;
}
const res =  addCarring(1)(2)(3);
console.log(res) 或alert(res) # console.log或alert会触发待输出对象的toString方法
```

#### 闭包
在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。

当通过调用一个外部函数返回一个内部函数后，**即使该外部函数已经执行结束了**，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些**变量的集合(包括内部函数和内部函数引用变量)称为闭包**。（在chrome中，这些变量保存在一个叫做Closure 的堆栈中）

好处：
- 缓存。将变量隐藏起来不被 GC 回收。
- 实现柯里化。利用闭包特性完成柯里化。

坏处：
- 内存消耗。闭包产生的变量无法被销毁。
- 性能问题。由于闭包内部变量优先级高于外部变量，所以需要多查找作用域链的一个层次，一定程度影响查找速度。

##### 闭包变量的生命周期

变量的生命周期取决于闭包的生命周期。被闭包引用的外部作用域中的变量将**一直存活直到闭包函数被销毁**。如果一个变量被多个闭包所引用，那么直到**所有的闭包被垃圾回收后**，该变量才会被销毁。

##### 函数与私有状态
通过闭包，我们可以创建拥有私有状态的函数，闭包使得状态被封装起来。

